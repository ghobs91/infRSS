(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_e058db4f._.js", {

"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/next/dist/compiled/querystring-es3/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    "use strict";
    var e = {
        815: function(e) {
            function hasOwnProperty(e, r) {
                return Object.prototype.hasOwnProperty.call(e, r);
            }
            e.exports = function(e, n, t, o) {
                n = n || "&";
                t = t || "=";
                var a = {};
                if (typeof e !== "string" || e.length === 0) {
                    return a;
                }
                var i = /\+/g;
                e = e.split(n);
                var u = 1e3;
                if (o && typeof o.maxKeys === "number") {
                    u = o.maxKeys;
                }
                var c = e.length;
                if (u > 0 && c > u) {
                    c = u;
                }
                for(var p = 0; p < c; ++p){
                    var f = e[p].replace(i, "%20"), s = f.indexOf(t), _, l, y, d;
                    if (s >= 0) {
                        _ = f.substr(0, s);
                        l = f.substr(s + 1);
                    } else {
                        _ = f;
                        l = "";
                    }
                    y = decodeURIComponent(_);
                    d = decodeURIComponent(l);
                    if (!hasOwnProperty(a, y)) {
                        a[y] = d;
                    } else if (r(a[y])) {
                        a[y].push(d);
                    } else {
                        a[y] = [
                            a[y],
                            d
                        ];
                    }
                }
                return a;
            };
            var r = Array.isArray || function(e) {
                return Object.prototype.toString.call(e) === "[object Array]";
            };
        },
        577: function(e) {
            var stringifyPrimitive = function(e) {
                switch(typeof e){
                    case "string":
                        return e;
                    case "boolean":
                        return e ? "true" : "false";
                    case "number":
                        return isFinite(e) ? e : "";
                    default:
                        return "";
                }
            };
            e.exports = function(e, t, o, a) {
                t = t || "&";
                o = o || "=";
                if (e === null) {
                    e = undefined;
                }
                if (typeof e === "object") {
                    return map(n(e), function(n) {
                        var a = encodeURIComponent(stringifyPrimitive(n)) + o;
                        if (r(e[n])) {
                            return map(e[n], function(e) {
                                return a + encodeURIComponent(stringifyPrimitive(e));
                            }).join(t);
                        } else {
                            return a + encodeURIComponent(stringifyPrimitive(e[n]));
                        }
                    }).join(t);
                }
                if (!a) return "";
                return encodeURIComponent(stringifyPrimitive(a)) + o + encodeURIComponent(stringifyPrimitive(e));
            };
            var r = Array.isArray || function(e) {
                return Object.prototype.toString.call(e) === "[object Array]";
            };
            function map(e, r) {
                if (e.map) return e.map(r);
                var n = [];
                for(var t = 0; t < e.length; t++){
                    n.push(r(e[t], t));
                }
                return n;
            }
            var n = Object.keys || function(e) {
                var r = [];
                for(var n in e){
                    if (Object.prototype.hasOwnProperty.call(e, n)) r.push(n);
                }
                return r;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(n) {
        var t = r[n];
        if (t !== undefined) {
            return t.exports;
        }
        var o = r[n] = {
            exports: {}
        };
        var a = true;
        try {
            e[n](o, o.exports, __nccwpck_require__);
            a = false;
        } finally{
            if (a) delete r[n];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var n = {};
    !function() {
        var e = n;
        e.decode = e.parse = __nccwpck_require__(815);
        e.encode = e.stringify = __nccwpck_require__(577);
    }();
    module.exports = n;
})();
}}),
"[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        452: function(e) {
            "use strict";
            e.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/querystring-es3/index.js [app-client] (ecmascript)");
        }
    };
    var t = {};
    function __nccwpck_require__(o) {
        var a = t[o];
        if (a !== undefined) {
            return a.exports;
        }
        var s = t[o] = {
            exports: {}
        };
        var n = true;
        try {
            e[o](s, s.exports, __nccwpck_require__);
            n = false;
        } finally{
            if (n) delete t[o];
        }
        return s.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var o = {};
    !function() {
        var e = o;
        var t, a = (t = __nccwpck_require__(452)) && "object" == typeof t && "default" in t ? t.default : t, s = /https?|ftp|gopher|file/;
        function r(e) {
            "string" == typeof e && (e = d(e));
            var t = function(e, t, o) {
                var a = e.auth, s = e.hostname, n = e.protocol || "", p = e.pathname || "", c = e.hash || "", i = e.query || "", u = !1;
                a = a ? encodeURIComponent(a).replace(/%3A/i, ":") + "@" : "", e.host ? u = a + e.host : s && (u = a + (~s.indexOf(":") ? "[" + s + "]" : s), e.port && (u += ":" + e.port)), i && "object" == typeof i && (i = t.encode(i));
                var f = e.search || i && "?" + i || "";
                return n && ":" !== n.substr(-1) && (n += ":"), e.slashes || (!n || o.test(n)) && !1 !== u ? (u = "//" + (u || ""), p && "/" !== p[0] && (p = "/" + p)) : u || (u = ""), c && "#" !== c[0] && (c = "#" + c), f && "?" !== f[0] && (f = "?" + f), {
                    protocol: n,
                    host: u,
                    pathname: p = p.replace(/[?#]/g, encodeURIComponent),
                    search: f = f.replace("#", "%23"),
                    hash: c
                };
            }(e, a, s);
            return "" + t.protocol + t.host + t.pathname + t.search + t.hash;
        }
        var n = "http://", p = "w.w", c = n + p, i = /^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i, u = /https?|ftp|gopher|file/;
        function h(e, t) {
            var o = "string" == typeof e ? d(e) : e;
            e = "object" == typeof e ? r(e) : e;
            var a = d(t), s = "";
            o.protocol && !o.slashes && (s = o.protocol, e = e.replace(o.protocol, ""), s += "/" === t[0] || "/" === e[0] ? "/" : ""), s && a.protocol && (s = "", a.slashes || (s = a.protocol, t = t.replace(a.protocol, "")));
            var p = e.match(i);
            p && !a.protocol && (e = e.substr((s = p[1] + (p[2] || "")).length), /^\/\/[^/]/.test(t) && (s = s.slice(0, -1)));
            var f = new URL(e, c + "/"), m = new URL(t, f).toString().replace(c, ""), v = a.protocol || o.protocol;
            return v += o.slashes || a.slashes ? "//" : "", !s && v ? m = m.replace(n, v) : s && (m = m.replace(n, "")), u.test(m) || ~t.indexOf(".") || "/" === e.slice(-1) || "/" === t.slice(-1) || "/" !== m.slice(-1) || (m = m.slice(0, -1)), s && (m = s + ("/" === m[0] ? m.substr(1) : m)), m;
        }
        function l() {}
        l.prototype.parse = d, l.prototype.format = r, l.prototype.resolve = h, l.prototype.resolveObject = h;
        var f = /^https?|ftp|gopher|file/, m = /^(.*?)([#?].*)/, v = /^([a-z0-9.+-]*:)(\/{0,3})(.*)/i, _ = /^([a-z0-9.+-]*:)?\/\/\/*/i, b = /^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;
        function d(e, t, o) {
            if (void 0 === t && (t = !1), void 0 === o && (o = !1), e && "object" == typeof e && e instanceof l) return e;
            var s = (e = e.trim()).match(m);
            e = s ? s[1].replace(/\\/g, "/") + s[2] : e.replace(/\\/g, "/"), b.test(e) && "/" !== e.slice(-1) && (e += "/");
            var n = !/(^javascript)/.test(e) && e.match(v), i = _.test(e), u = "";
            n && (f.test(n[1]) || (u = n[1].toLowerCase(), e = "" + n[2] + n[3]), n[2] || (i = !1, f.test(n[1]) ? (u = n[1], e = "" + n[3]) : e = "//" + n[3]), 3 !== n[2].length && 1 !== n[2].length || (u = n[1], e = "/" + n[3]));
            var g, y = (s ? s[1] : e).match(/^https?:\/\/[^/]+(:[0-9]+)(?=\/|$)/), w = y && y[1], x = new l, C = "", U = "";
            try {
                g = new URL(e);
            } catch (t) {
                C = t, u || o || !/^\/\//.test(e) || /^\/\/.+[@.]/.test(e) || (U = "/", e = e.substr(1));
                try {
                    g = new URL(e, c);
                } catch (e) {
                    return x.protocol = u, x.href = u, x;
                }
            }
            x.slashes = i && !U, x.host = g.host === p ? "" : g.host, x.hostname = g.hostname === p ? "" : g.hostname.replace(/(\[|\])/g, ""), x.protocol = C ? u || null : g.protocol, x.search = g.search.replace(/\\/g, "%5C"), x.hash = g.hash.replace(/\\/g, "%5C");
            var j = e.split("#");
            !x.search && ~j[0].indexOf("?") && (x.search = "?"), x.hash || "" !== j[1] || (x.hash = "#"), x.query = t ? a.decode(g.search.substr(1)) : x.search.substr(1), x.pathname = U + (n ? function(e) {
                return e.replace(/['^|`]/g, function(e) {
                    return "%" + e.charCodeAt().toString(16).toUpperCase();
                }).replace(/((?:%[0-9A-F]{2})+)/g, function(e, t) {
                    try {
                        return decodeURIComponent(t).split("").map(function(e) {
                            var t = e.charCodeAt();
                            return t > 256 || /^[a-z0-9]$/i.test(e) ? e : "%" + t.toString(16).toUpperCase();
                        }).join("");
                    } catch (e) {
                        return t;
                    }
                });
            }(g.pathname) : g.pathname), "about:" === x.protocol && "blank" === x.pathname && (x.protocol = "", x.pathname = ""), C && "/" !== e[0] && (x.pathname = x.pathname.substr(1)), u && !f.test(u) && "/" !== e.slice(-1) && "/" === x.pathname && (x.pathname = ""), x.path = x.pathname + x.search, x.auth = [
                g.username,
                g.password
            ].map(decodeURIComponent).filter(Boolean).join(":"), x.port = g.port, w && !x.host.endsWith(w) && (x.host += w, x.port = w.slice(1)), x.href = U ? "" + x.pathname + x.search + x.hash : r(x);
            var q = /^(file)/.test(x.href) ? [
                "host",
                "hostname"
            ] : [];
            return Object.keys(x).forEach(function(e) {
                ~q.indexOf(e) || (x[e] = x[e] || null);
            }), x;
        }
        e.parse = d, e.format = r, e.resolve = h, e.resolveObject = function(e, t) {
            return d(h(e, t));
        }, e.Url = l;
    }();
    module.exports = o;
})();
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "registerBackend": (()=>registerBackend),
    "resolveBackend": (()=>resolveBackend)
});
const backends = {};
const backendsSortedByPriority = [];
const registerBackend = (name, backend, priority)=>{
    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {
        const currentBackend = backends[name];
        if (currentBackend === undefined) {
            backends[name] = {
                backend,
                priority
            };
        } else if (currentBackend.priority > priority) {
            // same name is already registered with a higher priority. skip registeration.
            return;
        } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
                throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
        }
        if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
                backendsSortedByPriority.splice(i, 1);
            }
            for(let i = 0; i < backendsSortedByPriority.length; i++){
                if (backends[backendsSortedByPriority[i]].priority <= priority) {
                    backendsSortedByPriority.splice(i, 0, name);
                    return;
                }
            }
            backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
const resolveBackend = async (backendHints)=>{
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames){
        const backendInfo = backends[backendName];
        if (backendInfo) {
            if (backendInfo.initialized) {
                return backendInfo.backend;
            } else if (backendInfo.aborted) {
                continue; // current backend is unavailable; try next
            }
            const isInitializing = !!backendInfo.initPromise;
            try {
                if (!isInitializing) {
                    backendInfo.initPromise = backendInfo.backend.init();
                }
                await backendInfo.initPromise;
                backendInfo.initialized = true;
                return backendInfo.backend;
            } catch (e) {
                if (!isInitializing) {
                    errors.push({
                        name: backendName,
                        err: e
                    });
                }
                backendInfo.aborted = true;
            } finally{
                delete backendInfo.initPromise;
            }
        }
    }
    throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`).join(', ')}`);
}; //# sourceMappingURL=backend-impl.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=backend.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/env-impl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "EnvImpl": (()=>EnvImpl)
});
class EnvImpl {
    constructor(){
        this.wasm = {};
        this.webgl = {};
        this.logLevelInternal = 'warning';
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || [
            'verbose',
            'info',
            'warning',
            'error',
            'fatal'
        ].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        this.logLevelInternal = value;
    }
    get logLevel() {
        return this.logLevelInternal;
    }
} //# sourceMappingURL=env-impl.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/env.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "env": (()=>env)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/env-impl.js [app-client] (ecmascript)");
;
const env = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnvImpl"](); //# sourceMappingURL=env.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/tensor-impl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "Tensor": (()=>Tensor)
});
const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';
const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    [
        'float32',
        Float32Array
    ],
    [
        'uint8',
        Uint8Array
    ],
    [
        'int8',
        Int8Array
    ],
    [
        'uint16',
        Uint16Array
    ],
    [
        'int16',
        Int16Array
    ],
    [
        'int32',
        Int32Array
    ],
    [
        'bool',
        Uint8Array
    ],
    [
        'float64',
        Float64Array
    ],
    [
        'uint32',
        Uint32Array
    ]
]);
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [
        Float32Array,
        'float32'
    ],
    [
        Uint8Array,
        'uint8'
    ],
    [
        Int8Array,
        'int8'
    ],
    [
        Uint16Array,
        'uint16'
    ],
    [
        Int16Array,
        'int16'
    ],
    [
        Int32Array,
        'int32'
    ],
    [
        Float64Array,
        'float64'
    ],
    [
        Uint32Array,
        'uint32'
    ]
]);
if (isBigInt64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
}
if (isBigUint64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
}
/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */ const calculateSize = (dims)=>{
    let size = 1;
    for(let i = 0; i < dims.length; i++){
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
class Tensor {
    constructor(arg0, arg1, arg2){
        let type;
        let data;
        let dims;
        // check whether arg0 is type or data
        if (typeof arg0 === 'string') {
            //
            // Override: constructor(type, data, ...)
            //
            type = arg0;
            dims = arg2;
            if (arg0 === 'string') {
                // string tensor
                if (!Array.isArray(arg1)) {
                    throw new TypeError('A string tensor\'s data must be a string array.');
                }
                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                // error will be populated at inference
                data = arg1;
            } else {
                // numeric tensor
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === undefined) {
                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces
                    // incorrect results.
                    // 'typedArrayConstructor' should be one of the typed array prototype objects.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = typedArrayConstructor.from(arg1);
                } else if (arg1 instanceof typedArrayConstructor) {
                    data = arg1;
                } else {
                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
            }
        } else {
            //
            // Override: constructor(data, ...)
            //
            dims = arg1;
            if (Array.isArray(arg0)) {
                // only boolean[] and string[] is supported
                if (arg0.length === 0) {
                    throw new TypeError('Tensor type cannot be inferred from an empty array.');
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === 'string') {
                    type = 'string';
                    data = arg0;
                } else if (firstElementType === 'boolean') {
                    type = 'bool';
                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                    // wrong type. We use 'as any' to make it happy.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = Uint8Array.from(arg0);
                } else {
                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
            } else {
                // get tensor type from TypedArray
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === undefined) {
                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
            }
        }
        // type and data is processed, now processing dims
        if (dims === undefined) {
            // assume 1-D tensor if dims omitted
            dims = [
                data.length
            ];
        } else if (!Array.isArray(dims)) {
            throw new TypeError('A tensor\'s dims must be a number array');
        }
        // perform check
        const size = calculateSize(dims);
        if (size !== data.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
        }
        this.dims = dims;
        this.type = type;
        this.data = data;
        this.size = size;
    }
    // #endregion
    /**
     * Create a new tensor object from image object
     *
     * @param buffer - Extracted image buffer data - assuming RGBA format
     * @param imageFormat - input image configuration - required configurations height, width, format
     * @param tensorFormat - output tensor configuration - Default is RGB format
     */ static bufferToTensor(buffer, options) {
        if (buffer === undefined) {
            throw new Error('Image buffer must be defined');
        }
        if (options.height === undefined || options.width === undefined) {
            throw new Error('Image height and width must be defined');
        }
        const { height, width } = options;
        const norm = options.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = 255;
        } else {
            normMean = norm.mean;
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = 0;
        } else {
            normBias = norm.bias;
        }
        const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';
        // default value is RGBA since imagedata and HTMLImageElement uses it
        const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : 'RGB' : 'RGB';
        const offset = height * width;
        const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);
        // Default pointer assignments
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGB') {
            step = 3;
            rImagePointer = 0;
            gImagePointer = 1;
            bImagePointer = 2;
            aImagePointer = -1;
        }
        // Updating the pointer assignments based on the output tensor format
        if (outputformat === 'RGBA') {
            aTensorPointer = offset * 3;
        } else if (outputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = offset;
            gTensorPointer = offset * 2;
        } else if (outputformat === 'BGR') {
            bTensorPointer = 0;
            gTensorPointer = offset;
            rTensorPointer = offset * 2;
        }
        for(let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step){
            float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
            float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
            float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
            if (aTensorPointer !== -1 && aImagePointer !== -1) {
                float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
            }
        }
        // Float32Array -> ort.Tensor
        const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [
            1,
            4,
            height,
            width
        ]) : new Tensor('float32', float32Data, [
            1,
            3,
            height,
            width
        ]);
        return outputTensor;
    }
    static async fromImage(image, options) {
        // checking the type of image object
        const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;
        const isURL = typeof String !== 'undefined' && (image instanceof String || typeof image === 'string');
        let data;
        let tensorConfig = {};
        // filling and checking image configuration options
        if (isHTMLImageEle) {
            // HTMLImageElement - image object - format is RGBA by default
            const canvas = document.createElement('canvas');
            const pixels2DContext = canvas.getContext('2d');
            if (pixels2DContext != null) {
                let height = image.naturalHeight;
                let width = image.naturalWidth;
                if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {
                    height = options.resizedHeight;
                    width = options.resizedWidth;
                }
                if (options !== undefined) {
                    tensorConfig = options;
                    if (options.tensorFormat !== undefined) {
                        throw new Error('Image input config format must be RGBA for HTMLImageElement');
                    } else {
                        tensorConfig.tensorFormat = 'RGBA';
                    }
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match HTMLImageElement height');
                    } else {
                        tensorConfig.height = height;
                    }
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match HTMLImageElement width');
                    } else {
                        tensorConfig.width = width;
                    }
                } else {
                    tensorConfig.tensorFormat = 'RGBA';
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                canvas.width = width;
                canvas.height = height;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
                throw new Error('Can not access image data');
            }
        } else if (isImageDataEle) {
            // ImageData - image object - format is RGBA by default
            const format = 'RGBA';
            let height;
            let width;
            if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {
                height = options.resizedHeight;
                width = options.resizedWidth;
            } else {
                height = image.height;
                width = image.width;
            }
            if (options !== undefined) {
                tensorConfig = options;
                if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {
                    throw new Error('Image input config format must be RGBA for ImageData');
                } else {
                    tensorConfig.bitmapFormat = 'RGBA';
                }
            } else {
                tensorConfig.bitmapFormat = 'RGBA';
            }
            tensorConfig.height = height;
            tensorConfig.width = width;
            if (options !== undefined) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const pixels2DContext = tempCanvas.getContext('2d');
                if (pixels2DContext != null) {
                    pixels2DContext.putImageData(image, 0, 0);
                    data = pixels2DContext.getImageData(0, 0, width, height).data;
                } else {
                    throw new Error('Can not access image data');
                }
            } else {
                data = image.data;
            }
        } else if (isImageBitmap) {
            // ImageBitmap - image object - format must be provided by user
            if (options === undefined) {
                throw new Error('Please provide image config with format for Imagebitmap');
            }
            if (options.bitmapFormat !== undefined) {
                throw new Error('Image input config format must be defined for ImageBitmap');
            }
            const pixels2DContext = document.createElement('canvas').getContext('2d');
            if (pixels2DContext != null) {
                const height = image.height;
                const width = image.width;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
                if (options !== undefined) {
                    // using square brackets to avoid TS error - type 'never'
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match ImageBitmap height');
                    } else {
                        tensorConfig.height = height;
                    }
                    // using square brackets to avoid TS error - type 'never'
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match ImageBitmap width');
                    } else {
                        tensorConfig.width = width;
                    }
                } else {
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                return Tensor.bufferToTensor(data, tensorConfig);
            } else {
                throw new Error('Can not access image data');
            }
        } else if (isURL) {
            return new Promise((resolve, reject)=>{
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                if (!image || !context) {
                    return reject();
                }
                const newImage = new Image();
                newImage.crossOrigin = 'Anonymous';
                newImage.src = image;
                newImage.onload = ()=>{
                    canvas.width = newImage.width;
                    canvas.height = newImage.height;
                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                    const img = context.getImageData(0, 0, canvas.width, canvas.height);
                    if (options !== undefined) {
                        // using square brackets to avoid TS error - type 'never'
                        if (options.height !== undefined && options.height !== canvas.height) {
                            throw new Error('Image input config height doesn\'t match ImageBitmap height');
                        } else {
                            tensorConfig.height = canvas.height;
                        }
                        // using square brackets to avoid TS error - type 'never'
                        if (options.width !== undefined && options.width !== canvas.width) {
                            throw new Error('Image input config width doesn\'t match ImageBitmap width');
                        } else {
                            tensorConfig.width = canvas.width;
                        }
                    } else {
                        tensorConfig.height = canvas.height;
                        tensorConfig.width = canvas.width;
                    }
                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));
                };
            });
        } else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
        if (data !== undefined) {
            return Tensor.bufferToTensor(data, tensorConfig);
        } else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
    }
    toImageData(options) {
        var _a, _b;
        const pixels2DContext = document.createElement('canvas').getContext('2d');
        let image;
        if (pixels2DContext != null) {
            // Default values for height and width & format
            const width = this.dims[3];
            const height = this.dims[2];
            const channels = this.dims[1];
            const inputformat = options !== undefined ? options.format !== undefined ? options.format : 'RGB' : 'RGB';
            const normMean = options !== undefined ? ((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255 : 255;
            const normBias = options !== undefined ? ((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0 : 0;
            const offset = height * width;
            if (options !== undefined) {
                if (options.height !== undefined && options.height !== height) {
                    throw new Error('Image output config height doesn\'t match tensor height');
                }
                if (options.width !== undefined && options.width !== width) {
                    throw new Error('Image output config width doesn\'t match tensor width');
                }
                if (options.format !== undefined && channels === 4 && options.format !== 'RGBA' || channels === 3 && options.format !== 'RGB' && options.format !== 'BGR') {
                    throw new Error('Tensor format doesn\'t match input tensor dims');
                }
            }
            // Default pointer assignments
            const step = 4;
            let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
            let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
            // Updating the pointer assignments based on the input image format
            if (inputformat === 'RGBA') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
                aTensorPointer = offset * 3;
            } else if (inputformat === 'RGB') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
            } else if (inputformat === 'RBG') {
                rTensorPointer = 0;
                bTensorPointer = offset;
                gTensorPointer = offset * 2;
            }
            image = pixels2DContext.createImageData(width, height);
            for(let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++){
                image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value
                image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value
                image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value
                image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value
            }
        } else {
            throw new Error('Can not access image data');
        }
        return image;
    }
    // #endregion
    // #region tensor utilities
    reshape(dims) {
        return new Tensor(this.type, this.data, dims);
    }
} //# sourceMappingURL=tensor-impl.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "Tensor": (()=>Tensor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor-impl.js [app-client] (ecmascript)");
;
const Tensor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]; //# sourceMappingURL=tensor.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "InferenceSession": (()=>InferenceSession)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)");
;
;
class InferenceSession {
    constructor(handler){
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"] || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1){
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            } else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames){
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    } else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else {
                    options = arg1;
                }
            }
        } else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of this.inputNames){
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames){
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for(const key in results){
            if (Object.hasOwnProperty.call(results, key)) {
                returnValue[key] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"](results[key].type, results[key].data, results[key].dims);
            }
        }
        return returnValue;
    }
    static async create(arg0, arg1, arg2, arg3) {
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError('\'byteOffset\' must be an integer.');
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError('\'byteLength\' must be an integer.');
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    } else if (typeof arg3 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'byteLength\' must be a number.');
                }
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
            throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        }
        // get backend hints
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i)=>typeof i === 'string' ? i : i.name);
        const backend = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveBackend"])(backendHints);
        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
} //# sourceMappingURL=inference-session-impl.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/inference-session.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({
    "InferenceSession": (()=>InferenceSession)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js [app-client] (ecmascript)");
;
const InferenceSession = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InferenceSession"]; //# sourceMappingURL=inference-session.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/onnx-value.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s({});
;
 //# sourceMappingURL=onnx-value.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */ __turbopack_context__.s({});
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/env.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/inference-session.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$onnx$2d$value$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/onnx-value.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2d$impl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend-impl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InferenceSession": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InferenceSession"]),
    "Tensor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tensor"]),
    "env": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"]),
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$backend$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/backend.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$env$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/env.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$inference$2d$session$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/inference-session.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$tensor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/tensor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$onnx$2d$value$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/onnx-value.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InferenceSession": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["InferenceSession"]),
    "Tensor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Tensor"]),
    "env": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["env"]),
    "registerBackend": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["registerBackend"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/lib/index.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@huggingface/jinja/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lexer.ts
__turbopack_context__.s({
    "Environment": (()=>Environment),
    "Interpreter": (()=>Interpreter),
    "Template": (()=>Template),
    "parse": (()=>parse),
    "tokenize": (()=>tokenize)
});
var TOKEN_TYPES = Object.freeze({
    Text: "Text",
    // The text between Jinja statements or expressions
    NumericLiteral: "NumericLiteral",
    // e.g., 123
    BooleanLiteral: "BooleanLiteral",
    // true or false
    StringLiteral: "StringLiteral",
    // 'string'
    Identifier: "Identifier",
    // Variables, functions, etc.
    Equals: "Equals",
    // =
    OpenParen: "OpenParen",
    // (
    CloseParen: "CloseParen",
    // )
    OpenStatement: "OpenStatement",
    // {%
    CloseStatement: "CloseStatement",
    // %}
    OpenExpression: "OpenExpression",
    // {{
    CloseExpression: "CloseExpression",
    // }}
    OpenSquareBracket: "OpenSquareBracket",
    // [
    CloseSquareBracket: "CloseSquareBracket",
    // ]
    OpenCurlyBracket: "OpenCurlyBracket",
    // {
    CloseCurlyBracket: "CloseCurlyBracket",
    // }
    Comma: "Comma",
    // ,
    Dot: "Dot",
    // .
    Colon: "Colon",
    // :
    Pipe: "Pipe",
    // |
    CallOperator: "CallOperator",
    // ()
    AdditiveBinaryOperator: "AdditiveBinaryOperator",
    // + -
    MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
    // * / %
    ComparisonBinaryOperator: "ComparisonBinaryOperator",
    // < > <= >= == !=
    UnaryOperator: "UnaryOperator",
    // ! - +
    // Keywords
    Set: "Set",
    If: "If",
    For: "For",
    In: "In",
    Is: "Is",
    NotIn: "NotIn",
    Else: "Else",
    EndIf: "EndIf",
    ElseIf: "ElseIf",
    EndFor: "EndFor",
    And: "And",
    Or: "Or",
    Not: "UnaryOperator"
});
var KEYWORDS = Object.freeze({
    set: TOKEN_TYPES.Set,
    for: TOKEN_TYPES.For,
    in: TOKEN_TYPES.In,
    is: TOKEN_TYPES.Is,
    if: TOKEN_TYPES.If,
    else: TOKEN_TYPES.Else,
    endif: TOKEN_TYPES.EndIf,
    elif: TOKEN_TYPES.ElseIf,
    endfor: TOKEN_TYPES.EndFor,
    and: TOKEN_TYPES.And,
    or: TOKEN_TYPES.Or,
    not: TOKEN_TYPES.Not,
    "not in": TOKEN_TYPES.NotIn,
    // Literals
    true: TOKEN_TYPES.BooleanLiteral,
    false: TOKEN_TYPES.BooleanLiteral
});
var Token = class {
    /**
   * Constructs a new Token.
   * @param {string} value The raw value as seen inside the source code.
   * @param {TokenType} type The type of token.
   */ constructor(value, type){
        this.value = value;
        this.type = type;
    }
};
function isWord(char) {
    return /\w/.test(char);
}
function isInteger(char) {
    return /[0-9]/.test(char);
}
var ORDERED_MAPPING_TABLE = [
    // Control sequences
    [
        "{%",
        TOKEN_TYPES.OpenStatement
    ],
    [
        "%}",
        TOKEN_TYPES.CloseStatement
    ],
    [
        "{{",
        TOKEN_TYPES.OpenExpression
    ],
    [
        "}}",
        TOKEN_TYPES.CloseExpression
    ],
    // Single character tokens
    [
        "(",
        TOKEN_TYPES.OpenParen
    ],
    [
        ")",
        TOKEN_TYPES.CloseParen
    ],
    [
        "{",
        TOKEN_TYPES.OpenCurlyBracket
    ],
    [
        "}",
        TOKEN_TYPES.CloseCurlyBracket
    ],
    [
        "[",
        TOKEN_TYPES.OpenSquareBracket
    ],
    [
        "]",
        TOKEN_TYPES.CloseSquareBracket
    ],
    [
        ",",
        TOKEN_TYPES.Comma
    ],
    [
        ".",
        TOKEN_TYPES.Dot
    ],
    [
        ":",
        TOKEN_TYPES.Colon
    ],
    [
        "|",
        TOKEN_TYPES.Pipe
    ],
    // Comparison operators
    [
        "<=",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        ">=",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        "==",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        "!=",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        "<",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    [
        ">",
        TOKEN_TYPES.ComparisonBinaryOperator
    ],
    // Arithmetic operators
    [
        "+",
        TOKEN_TYPES.AdditiveBinaryOperator
    ],
    [
        "-",
        TOKEN_TYPES.AdditiveBinaryOperator
    ],
    [
        "*",
        TOKEN_TYPES.MultiplicativeBinaryOperator
    ],
    [
        "/",
        TOKEN_TYPES.MultiplicativeBinaryOperator
    ],
    [
        "%",
        TOKEN_TYPES.MultiplicativeBinaryOperator
    ],
    // Assignment operator
    [
        "=",
        TOKEN_TYPES.Equals
    ]
];
var ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([
    [
        "n",
        "\n"
    ],
    // New line
    [
        "t",
        "	"
    ],
    // Horizontal tab
    [
        "r",
        "\r"
    ],
    // Carriage return
    [
        "b",
        "\b"
    ],
    // Backspace
    [
        "f",
        "\f"
    ],
    // Form feed
    [
        "v",
        "\v"
    ],
    // Vertical tab
    [
        "'",
        "'"
    ],
    // Single quote
    [
        '"',
        '"'
    ],
    // Double quote
    [
        "\\",
        "\\"
    ]
]);
function preprocess(template, options = {}) {
    if (template.endsWith("\n")) {
        template = template.slice(0, -1);
    }
    template = template.replace(/{#.*?#}/gs, "{##}");
    if (options.lstrip_blocks) {
        template = template.replace(/^[ \t]*({[#%])/gm, "$1");
    }
    if (options.trim_blocks) {
        template = template.replace(/([#%]})\n/g, "$1");
    }
    return template.replace(/{##}/g, "").replace(/-%}\s*/g, "%}").replace(/\s*{%-/g, "{%").replace(/-}}\s*/g, "}}").replace(/\s*{{-/g, "{{");
}
function tokenize(source, options = {}) {
    const tokens = [];
    const src = preprocess(source, options);
    let cursorPosition = 0;
    const consumeWhile = (predicate)=>{
        let str = "";
        while(predicate(src[cursorPosition])){
            if (src[cursorPosition] === "\\") {
                ++cursorPosition;
                if (cursorPosition >= src.length) throw new SyntaxError("Unexpected end of input");
                const escaped = src[cursorPosition++];
                const unescaped = ESCAPE_CHARACTERS.get(escaped);
                if (unescaped === void 0) {
                    throw new SyntaxError(`Unexpected escaped character: ${escaped}`);
                }
                str += unescaped;
                continue;
            }
            str += src[cursorPosition++];
            if (cursorPosition >= src.length) throw new SyntaxError("Unexpected end of input");
        }
        return str;
    };
    main: while(cursorPosition < src.length){
        const lastTokenType = tokens.at(-1)?.type;
        if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {
            let text = "";
            while(cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression
            !(src[cursorPosition] === "{" && (src[cursorPosition + 1] === "%" || src[cursorPosition + 1] === "{"))){
                text += src[cursorPosition++];
            }
            if (text.length > 0) {
                tokens.push(new Token(text, TOKEN_TYPES.Text));
                continue;
            }
        }
        consumeWhile((char2)=>/\s/.test(char2));
        const char = src[cursorPosition];
        if (char === "-" || char === "+") {
            const lastTokenType2 = tokens.at(-1)?.type;
            if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {
                throw new SyntaxError(`Unexpected character: ${char}`);
            }
            switch(lastTokenType2){
                case TOKEN_TYPES.Identifier:
                case TOKEN_TYPES.NumericLiteral:
                case TOKEN_TYPES.BooleanLiteral:
                case TOKEN_TYPES.StringLiteral:
                case TOKEN_TYPES.CloseParen:
                case TOKEN_TYPES.CloseSquareBracket:
                    break;
                default:
                    {
                        ++cursorPosition;
                        const num = consumeWhile(isInteger);
                        tokens.push(new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator));
                        continue;
                    }
            }
        }
        for (const [char2, token] of ORDERED_MAPPING_TABLE){
            const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);
            if (slice2 === char2) {
                tokens.push(new Token(char2, token));
                cursorPosition += char2.length;
                continue main;
            }
        }
        if (char === "'" || char === '"') {
            ++cursorPosition;
            const str = consumeWhile((c)=>c !== char);
            tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));
            ++cursorPosition;
            continue;
        }
        if (isInteger(char)) {
            const num = consumeWhile(isInteger);
            tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));
            continue;
        }
        if (isWord(char)) {
            const word = consumeWhile(isWord);
            const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;
            if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {
                tokens.pop();
                tokens.push(new Token("not in", TOKEN_TYPES.NotIn));
            } else {
                tokens.push(new Token(word, type));
            }
            continue;
        }
        throw new SyntaxError(`Unexpected character: ${char}`);
    }
    return tokens;
}
// src/ast.ts
var Statement = class {
    type = "Statement";
};
var Program = class extends Statement {
    constructor(body){
        super();
        this.body = body;
    }
    type = "Program";
};
var If = class extends Statement {
    constructor(test, body, alternate){
        super();
        this.test = test;
        this.body = body;
        this.alternate = alternate;
    }
    type = "If";
};
var For = class extends Statement {
    constructor(loopvar, iterable, body){
        super();
        this.loopvar = loopvar;
        this.iterable = iterable;
        this.body = body;
    }
    type = "For";
};
var SetStatement = class extends Statement {
    constructor(assignee, value){
        super();
        this.assignee = assignee;
        this.value = value;
    }
    type = "Set";
};
var Expression = class extends Statement {
    type = "Expression";
};
var MemberExpression = class extends Expression {
    constructor(object, property, computed){
        super();
        this.object = object;
        this.property = property;
        this.computed = computed;
    }
    type = "MemberExpression";
};
var CallExpression = class extends Expression {
    constructor(callee, args){
        super();
        this.callee = callee;
        this.args = args;
    }
    type = "CallExpression";
};
var Identifier = class extends Expression {
    /**
   * @param {string} value The name of the identifier
   */ constructor(value){
        super();
        this.value = value;
    }
    type = "Identifier";
};
var Literal = class extends Expression {
    constructor(value){
        super();
        this.value = value;
    }
    type = "Literal";
};
var NumericLiteral = class extends Literal {
    type = "NumericLiteral";
};
var StringLiteral = class extends Literal {
    type = "StringLiteral";
};
var BooleanLiteral = class extends Literal {
    type = "BooleanLiteral";
};
var ArrayLiteral = class extends Literal {
    type = "ArrayLiteral";
};
var TupleLiteral = class extends Literal {
    type = "TupleLiteral";
};
var ObjectLiteral = class extends Literal {
    type = "ObjectLiteral";
};
var BinaryExpression = class extends Expression {
    constructor(operator, left, right){
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    type = "BinaryExpression";
};
var FilterExpression = class extends Expression {
    constructor(operand, filter){
        super();
        this.operand = operand;
        this.filter = filter;
    }
    type = "FilterExpression";
};
var TestExpression = class extends Expression {
    constructor(operand, negate, test){
        super();
        this.operand = operand;
        this.negate = negate;
        this.test = test;
    }
    type = "TestExpression";
};
var UnaryExpression = class extends Expression {
    constructor(operator, argument){
        super();
        this.operator = operator;
        this.argument = argument;
    }
    type = "UnaryExpression";
};
var SliceExpression = class extends Expression {
    constructor(start = void 0, stop = void 0, step = void 0){
        super();
        this.start = start;
        this.stop = stop;
        this.step = step;
    }
    type = "SliceExpression";
};
var KeywordArgumentExpression = class extends Expression {
    constructor(key, value){
        super();
        this.key = key;
        this.value = value;
    }
    type = "KeywordArgumentExpression";
};
// src/parser.ts
function parse(tokens) {
    const program = new Program([]);
    let current = 0;
    function expect(type, error) {
        const prev = tokens[current++];
        if (!prev || prev.type !== type) {
            throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);
        }
        return prev;
    }
    function parseAny() {
        switch(tokens[current].type){
            case TOKEN_TYPES.Text:
                return parseText();
            case TOKEN_TYPES.OpenStatement:
                return parseJinjaStatement();
            case TOKEN_TYPES.OpenExpression:
                return parseJinjaExpression();
            default:
                throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);
        }
    }
    function not(...types) {
        return current + types.length <= tokens.length && types.some((type, i)=>type !== tokens[current + i].type);
    }
    function is(...types) {
        return current + types.length <= tokens.length && types.every((type, i)=>type === tokens[current + i].type);
    }
    function parseText() {
        return new StringLiteral(expect(TOKEN_TYPES.Text, "Expected text token").value);
    }
    function parseJinjaStatement() {
        expect(TOKEN_TYPES.OpenStatement, "Expected opening statement token");
        let result;
        switch(tokens[current].type){
            case TOKEN_TYPES.Set:
                ++current;
                result = parseSetStatement();
                expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
                break;
            case TOKEN_TYPES.If:
                ++current;
                result = parseIfStatement();
                expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
                expect(TOKEN_TYPES.EndIf, "Expected endif token");
                expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
                break;
            case TOKEN_TYPES.For:
                ++current;
                result = parseForStatement();
                expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
                expect(TOKEN_TYPES.EndFor, "Expected endfor token");
                expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
                break;
            default:
                throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);
        }
        return result;
    }
    function parseJinjaExpression() {
        expect(TOKEN_TYPES.OpenExpression, "Expected opening expression token");
        const result = parseExpression();
        expect(TOKEN_TYPES.CloseExpression, "Expected closing expression token");
        return result;
    }
    function parseSetStatement() {
        const left = parseExpression();
        if (is(TOKEN_TYPES.Equals)) {
            ++current;
            const value = parseSetStatement();
            return new SetStatement(left, value);
        }
        return left;
    }
    function parseIfStatement() {
        const test = parseExpression();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        const alternate = [];
        while(!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))){
            body.push(parseAny());
        }
        if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {
            ++current;
            if (is(TOKEN_TYPES.ElseIf)) {
                expect(TOKEN_TYPES.ElseIf, "Expected elseif token");
                alternate.push(parseIfStatement());
            } else {
                expect(TOKEN_TYPES.Else, "Expected else token");
                expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
                while(!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)){
                    alternate.push(parseAny());
                }
            }
        }
        return new If(test, body, alternate);
    }
    function parseExpressionSequence(primary = false) {
        const fn = primary ? parsePrimaryExpression : parseExpression;
        const expressions = [
            fn()
        ];
        const isTuple = is(TOKEN_TYPES.Comma);
        while(isTuple){
            ++current;
            expressions.push(fn());
            if (!is(TOKEN_TYPES.Comma)) {
                break;
            }
        }
        return isTuple ? new TupleLiteral(expressions) : expressions[0];
    }
    function parseForStatement() {
        const loopVariable = parseExpressionSequence(true);
        if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {
            throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);
        }
        expect(TOKEN_TYPES.In, "Expected `in` keyword following loop variable");
        const iterable = parseExpression();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        while(not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)){
            body.push(parseAny());
        }
        return new For(loopVariable, iterable, body);
    }
    function parseExpression() {
        return parseTernaryExpression();
    }
    function parseTernaryExpression() {
        const a = parseLogicalOrExpression();
        if (is(TOKEN_TYPES.If)) {
            ++current;
            const predicate = parseLogicalOrExpression();
            expect(TOKEN_TYPES.Else, "Expected else token");
            const b = parseLogicalOrExpression();
            return new If(predicate, [
                a
            ], [
                b
            ]);
        }
        return a;
    }
    function parseLogicalOrExpression() {
        let left = parseLogicalAndExpression();
        while(is(TOKEN_TYPES.Or)){
            const operator = tokens[current];
            ++current;
            const right = parseLogicalAndExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseLogicalAndExpression() {
        let left = parseLogicalNegationExpression();
        while(is(TOKEN_TYPES.And)){
            const operator = tokens[current];
            ++current;
            const right = parseLogicalNegationExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseLogicalNegationExpression() {
        let right;
        while(is(TOKEN_TYPES.Not)){
            const operator = tokens[current];
            ++current;
            const arg = parseLogicalNegationExpression();
            right = new UnaryExpression(operator, arg);
        }
        return right ?? parseComparisonExpression();
    }
    function parseComparisonExpression() {
        let left = parseAdditiveExpression();
        while(is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)){
            const operator = tokens[current];
            ++current;
            const right = parseAdditiveExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseAdditiveExpression() {
        let left = parseMultiplicativeExpression();
        while(is(TOKEN_TYPES.AdditiveBinaryOperator)){
            const operator = tokens[current];
            ++current;
            const right = parseMultiplicativeExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseCallMemberExpression() {
        const member = parseMemberExpression();
        if (is(TOKEN_TYPES.OpenParen)) {
            return parseCallExpression(member);
        }
        return member;
    }
    function parseCallExpression(callee) {
        let callExpression = new CallExpression(callee, parseArgs());
        if (is(TOKEN_TYPES.OpenParen)) {
            callExpression = parseCallExpression(callExpression);
        }
        return callExpression;
    }
    function parseArgs() {
        expect(TOKEN_TYPES.OpenParen, "Expected opening parenthesis for arguments list");
        const args = parseArgumentsList();
        expect(TOKEN_TYPES.CloseParen, "Expected closing parenthesis for arguments list");
        return args;
    }
    function parseArgumentsList() {
        const args = [];
        while(!is(TOKEN_TYPES.CloseParen)){
            let argument = parseExpression();
            if (is(TOKEN_TYPES.Equals)) {
                ++current;
                if (!(argument instanceof Identifier)) {
                    throw new SyntaxError(`Expected identifier for keyword argument`);
                }
                const value = parseExpression();
                argument = new KeywordArgumentExpression(argument, value);
            }
            args.push(argument);
            if (is(TOKEN_TYPES.Comma)) {
                ++current;
            }
        }
        return args;
    }
    function parseMemberExpressionArgumentsList() {
        const slices = [];
        let isSlice = false;
        while(!is(TOKEN_TYPES.CloseSquareBracket)){
            if (is(TOKEN_TYPES.Colon)) {
                slices.push(void 0);
                ++current;
                isSlice = true;
            } else {
                slices.push(parseExpression());
                if (is(TOKEN_TYPES.Colon)) {
                    ++current;
                    isSlice = true;
                }
            }
        }
        if (slices.length === 0) {
            throw new SyntaxError(`Expected at least one argument for member/slice expression`);
        }
        if (isSlice) {
            if (slices.length > 3) {
                throw new SyntaxError(`Expected 0-3 arguments for slice expression`);
            }
            return new SliceExpression(...slices);
        }
        return slices[0];
    }
    function parseMemberExpression() {
        let object = parsePrimaryExpression();
        while(is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)){
            const operator = tokens[current];
            ++current;
            let property;
            const computed = operator.type !== TOKEN_TYPES.Dot;
            if (computed) {
                property = parseMemberExpressionArgumentsList();
                expect(TOKEN_TYPES.CloseSquareBracket, "Expected closing square bracket");
            } else {
                property = parsePrimaryExpression();
                if (property.type !== "Identifier") {
                    throw new SyntaxError(`Expected identifier following dot operator`);
                }
            }
            object = new MemberExpression(object, property, computed);
        }
        return object;
    }
    function parseMultiplicativeExpression() {
        let left = parseTestExpression();
        while(is(TOKEN_TYPES.MultiplicativeBinaryOperator)){
            const operator = tokens[current];
            ++current;
            const right = parseTestExpression();
            left = new BinaryExpression(operator, left, right);
        }
        return left;
    }
    function parseTestExpression() {
        let operand = parseFilterExpression();
        while(is(TOKEN_TYPES.Is)){
            ++current;
            const negate = is(TOKEN_TYPES.Not);
            if (negate) {
                ++current;
            }
            let filter = parsePrimaryExpression();
            if (filter instanceof BooleanLiteral) {
                filter = new Identifier(filter.value.toString());
            }
            if (!(filter instanceof Identifier)) {
                throw new SyntaxError(`Expected identifier for the test`);
            }
            operand = new TestExpression(operand, negate, filter);
        }
        return operand;
    }
    function parseFilterExpression() {
        let operand = parseCallMemberExpression();
        while(is(TOKEN_TYPES.Pipe)){
            ++current;
            let filter = parsePrimaryExpression();
            if (!(filter instanceof Identifier)) {
                throw new SyntaxError(`Expected identifier for the filter`);
            }
            if (is(TOKEN_TYPES.OpenParen)) {
                filter = parseCallExpression(filter);
            }
            operand = new FilterExpression(operand, filter);
        }
        return operand;
    }
    function parsePrimaryExpression() {
        const token = tokens[current];
        switch(token.type){
            case TOKEN_TYPES.NumericLiteral:
                ++current;
                return new NumericLiteral(Number(token.value));
            case TOKEN_TYPES.StringLiteral:
                ++current;
                return new StringLiteral(token.value);
            case TOKEN_TYPES.BooleanLiteral:
                ++current;
                return new BooleanLiteral(token.value === "true");
            case TOKEN_TYPES.Identifier:
                ++current;
                return new Identifier(token.value);
            case TOKEN_TYPES.OpenParen:
                {
                    ++current;
                    const expression = parseExpressionSequence();
                    if (tokens[current].type !== TOKEN_TYPES.CloseParen) {
                        throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);
                    }
                    ++current;
                    return expression;
                }
            case TOKEN_TYPES.OpenSquareBracket:
                {
                    ++current;
                    const values = [];
                    while(!is(TOKEN_TYPES.CloseSquareBracket)){
                        values.push(parseExpression());
                        if (is(TOKEN_TYPES.Comma)) {
                            ++current;
                        }
                    }
                    ++current;
                    return new ArrayLiteral(values);
                }
            case TOKEN_TYPES.OpenCurlyBracket:
                {
                    ++current;
                    const values = /* @__PURE__ */ new Map();
                    while(!is(TOKEN_TYPES.CloseCurlyBracket)){
                        const key = parseExpression();
                        expect(TOKEN_TYPES.Colon, "Expected colon between key and value in object literal");
                        const value = parseExpression();
                        values.set(key, value);
                        if (is(TOKEN_TYPES.Comma)) {
                            ++current;
                        }
                    }
                    ++current;
                    return new ObjectLiteral(values);
                }
            default:
                throw new SyntaxError(`Unexpected token: ${token.type}`);
        }
    }
    while(current < tokens.length){
        program.body.push(parseAny());
    }
    return program;
}
// src/utils.ts
function range(start, stop, step = 1) {
    if (stop === void 0) {
        stop = start;
        start = 0;
    }
    const result = [];
    for(let i = start; i < stop; i += step){
        result.push(i);
    }
    return result;
}
function slice(array, start, stop, step = 1) {
    const direction = Math.sign(step);
    if (direction >= 0) {
        start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);
        stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);
    } else {
        start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);
        stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);
    }
    const result = [];
    for(let i = start; direction * i < direction * stop; i += step){
        result.push(array[i]);
    }
    return result;
}
function titleCase(value) {
    return value.replace(/\b\w/g, (c)=>c.toUpperCase());
}
// src/runtime.ts
var RuntimeValue = class {
    type = "RuntimeValue";
    value;
    /**
   * A collection of built-in functions for this type.
   */ builtins = /* @__PURE__ */ new Map();
    /**
   * Creates a new RuntimeValue.
   */ constructor(value = void 0){
        this.value = value;
    }
    /**
   * Determines truthiness or falsiness of the runtime value.
   * This function should be overridden by subclasses if it has custom truthiness criteria.
   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.
   */ __bool__() {
        return new BooleanValue(!!this.value);
    }
};
var NumericValue = class extends RuntimeValue {
    type = "NumericValue";
};
var StringValue = class extends RuntimeValue {
    type = "StringValue";
    builtins = /* @__PURE__ */ new Map([
        [
            "upper",
            new FunctionValue(()=>{
                return new StringValue(this.value.toUpperCase());
            })
        ],
        [
            "lower",
            new FunctionValue(()=>{
                return new StringValue(this.value.toLowerCase());
            })
        ],
        [
            "strip",
            new FunctionValue(()=>{
                return new StringValue(this.value.trim());
            })
        ],
        [
            "title",
            new FunctionValue(()=>{
                return new StringValue(titleCase(this.value));
            })
        ],
        [
            "length",
            new NumericValue(this.value.length)
        ]
    ]);
};
var BooleanValue = class extends RuntimeValue {
    type = "BooleanValue";
};
var ObjectValue = class extends RuntimeValue {
    type = "ObjectValue";
    /**
   * NOTE: necessary to override since all JavaScript arrays are considered truthy,
   * while only non-empty Python arrays are consider truthy.
   *
   * e.g.,
   *  - JavaScript:  {} && 5 -> 5
   *  - Python:      {} and 5 -> {}
   */ __bool__() {
        return new BooleanValue(this.value.size > 0);
    }
    builtins = /* @__PURE__ */ new Map([
        [
            "get",
            new FunctionValue(([key, defaultValue])=>{
                if (!(key instanceof StringValue)) {
                    throw new Error(`Object key must be a string: got ${key.type}`);
                }
                return this.value.get(key.value) ?? defaultValue ?? new NullValue();
            })
        ],
        [
            "items",
            new FunctionValue(()=>{
                return new ArrayValue(Array.from(this.value.entries()).map(([key, value])=>new ArrayValue([
                        new StringValue(key),
                        value
                    ])));
            })
        ]
    ]);
};
var ArrayValue = class extends RuntimeValue {
    type = "ArrayValue";
    builtins = /* @__PURE__ */ new Map([
        [
            "length",
            new NumericValue(this.value.length)
        ]
    ]);
    /**
   * NOTE: necessary to override since all JavaScript arrays are considered truthy,
   * while only non-empty Python arrays are consider truthy.
   *
   * e.g.,
   *  - JavaScript:  [] && 5 -> 5
   *  - Python:      [] and 5 -> []
   */ __bool__() {
        return new BooleanValue(this.value.length > 0);
    }
};
var TupleValue = class extends ArrayValue {
    type = "TupleValue";
};
var FunctionValue = class extends RuntimeValue {
    type = "FunctionValue";
};
var NullValue = class extends RuntimeValue {
    type = "NullValue";
};
var UndefinedValue = class extends RuntimeValue {
    type = "UndefinedValue";
};
var Environment = class {
    constructor(parent){
        this.parent = parent;
    }
    /**
   * The variables declared in this environment.
   */ variables = /* @__PURE__ */ new Map([
        [
            "namespace",
            new FunctionValue((args)=>{
                if (args.length === 0) {
                    return new ObjectValue(/* @__PURE__ */ new Map());
                }
                if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {
                    throw new Error("`namespace` expects either zero arguments or a single object argument");
                }
                return args[0];
            })
        ]
    ]);
    /**
   * The tests available in this environment.
   */ tests = /* @__PURE__ */ new Map([
        [
            "boolean",
            (operand)=>operand.type === "BooleanValue"
        ],
        [
            "callable",
            (operand)=>operand instanceof FunctionValue
        ],
        [
            "odd",
            (operand)=>{
                if (operand.type !== "NumericValue") {
                    throw new Error(`Cannot apply test "odd" to type: ${operand.type}`);
                }
                return operand.value % 2 !== 0;
            }
        ],
        [
            "even",
            (operand)=>{
                if (operand.type !== "NumericValue") {
                    throw new Error(`Cannot apply test "even" to type: ${operand.type}`);
                }
                return operand.value % 2 === 0;
            }
        ],
        [
            "false",
            (operand)=>operand.type === "BooleanValue" && !operand.value
        ],
        [
            "true",
            (operand)=>operand.type === "BooleanValue" && operand.value
        ],
        [
            "number",
            (operand)=>operand.type === "NumericValue"
        ],
        [
            "integer",
            (operand)=>operand.type === "NumericValue" && Number.isInteger(operand.value)
        ],
        [
            "iterable",
            (operand)=>operand instanceof ArrayValue || operand instanceof StringValue
        ],
        [
            "lower",
            (operand)=>{
                const str = operand.value;
                return operand.type === "StringValue" && str === str.toLowerCase();
            }
        ],
        [
            "upper",
            (operand)=>{
                const str = operand.value;
                return operand.type === "StringValue" && str === str.toUpperCase();
            }
        ],
        [
            "none",
            (operand)=>operand.type === "NullValue"
        ],
        [
            "defined",
            (operand)=>operand.type !== "UndefinedValue"
        ],
        [
            "undefined",
            (operand)=>operand.type === "UndefinedValue"
        ],
        [
            "equalto",
            (a, b)=>a.value === b.value
        ]
    ]);
    /**
   * Set the value of a variable in the current environment.
   */ set(name, value) {
        return this.declareVariable(name, convertToRuntimeValues(value));
    }
    declareVariable(name, value) {
        if (this.variables.has(name)) {
            throw new SyntaxError(`Variable already declared: ${name}`);
        }
        this.variables.set(name, value);
        return value;
    }
    // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {
    // 	const env = this.resolve(name);
    // 	env.variables.set(name, value);
    // 	return value;
    // }
    /**
   * Set variable in the current scope.
   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.
   */ setVariable(name, value) {
        this.variables.set(name, value);
        return value;
    }
    /**
   * Resolve the environment in which the variable is declared.
   * @param {string} name The name of the variable.
   * @returns {Environment} The environment in which the variable is declared.
   */ resolve(name) {
        if (this.variables.has(name)) {
            return this;
        }
        if (this.parent) {
            return this.parent.resolve(name);
        }
        throw new Error(`Unknown variable: ${name}`);
    }
    lookupVariable(name) {
        try {
            return this.resolve(name).variables.get(name) ?? new UndefinedValue();
        } catch  {
            return new UndefinedValue();
        }
    }
};
var Interpreter = class {
    global;
    constructor(env){
        this.global = env ?? new Environment();
    }
    /**
   * Run the program.
   */ run(program) {
        return this.evaluate(program, this.global);
    }
    /**
   * Evaluates expressions following the binary operation type.
   */ evaluateBinaryExpression(node, environment) {
        const left = this.evaluate(node.left, environment);
        switch(node.operator.value){
            case "and":
                return left.__bool__().value ? this.evaluate(node.right, environment) : left;
            case "or":
                return left.__bool__().value ? left : this.evaluate(node.right, environment);
        }
        const right = this.evaluate(node.right, environment);
        switch(node.operator.value){
            case "==":
                return new BooleanValue(left.value == right.value);
            case "!=":
                return new BooleanValue(left.value != right.value);
        }
        if (left instanceof UndefinedValue || right instanceof UndefinedValue) {
            throw new Error("Cannot perform operation on undefined values");
        } else if (left instanceof NullValue || right instanceof NullValue) {
            throw new Error("Cannot perform operation on null values");
        } else if (left instanceof NumericValue && right instanceof NumericValue) {
            switch(node.operator.value){
                case "+":
                    return new NumericValue(left.value + right.value);
                case "-":
                    return new NumericValue(left.value - right.value);
                case "*":
                    return new NumericValue(left.value * right.value);
                case "/":
                    return new NumericValue(left.value / right.value);
                case "%":
                    return new NumericValue(left.value % right.value);
                case "<":
                    return new BooleanValue(left.value < right.value);
                case ">":
                    return new BooleanValue(left.value > right.value);
                case ">=":
                    return new BooleanValue(left.value >= right.value);
                case "<=":
                    return new BooleanValue(left.value <= right.value);
            }
        } else if (left instanceof ArrayValue && right instanceof ArrayValue) {
            switch(node.operator.value){
                case "+":
                    return new ArrayValue(left.value.concat(right.value));
            }
        } else if (right instanceof ArrayValue) {
            const member = right.value.find((x)=>x.value === left.value) !== void 0;
            switch(node.operator.value){
                case "in":
                    return new BooleanValue(member);
                case "not in":
                    return new BooleanValue(!member);
            }
        }
        if (left instanceof StringValue || right instanceof StringValue) {
            switch(node.operator.value){
                case "+":
                    return new StringValue(left.value.toString() + right.value.toString());
            }
        }
        if (left instanceof StringValue && right instanceof StringValue) {
            switch(node.operator.value){
                case "in":
                    return new BooleanValue(right.value.includes(left.value));
                case "not in":
                    return new BooleanValue(!right.value.includes(left.value));
            }
        }
        if (left instanceof StringValue && right instanceof ObjectValue) {
            switch(node.operator.value){
                case "in":
                    return new BooleanValue(right.value.has(left.value));
                case "not in":
                    return new BooleanValue(!right.value.has(left.value));
            }
        }
        throw new SyntaxError(`Unknown operator "${node.operator.value}" between ${left.type} and ${right.type}`);
    }
    /**
   * Evaluates expressions following the filter operation type.
   */ evaluateFilterExpression(node, environment) {
        const operand = this.evaluate(node.operand, environment);
        if (node.filter.type === "Identifier") {
            const filter = node.filter;
            if (operand instanceof ArrayValue) {
                switch(filter.value){
                    case "list":
                        return operand;
                    case "first":
                        return operand.value[0];
                    case "last":
                        return operand.value[operand.value.length - 1];
                    case "length":
                        return new NumericValue(operand.value.length);
                    case "reverse":
                        return new ArrayValue(operand.value.reverse());
                    case "sort":
                        return new ArrayValue(operand.value.sort((a, b)=>{
                            if (a.type !== b.type) {
                                throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);
                            }
                            switch(a.type){
                                case "NumericValue":
                                    return a.value - b.value;
                                case "StringValue":
                                    return a.value.localeCompare(b.value);
                                default:
                                    throw new Error(`Cannot compare type: ${a.type}`);
                            }
                        }));
                    default:
                        throw new Error(`Unknown ArrayValue filter: ${filter.value}`);
                }
            } else if (operand instanceof StringValue) {
                switch(filter.value){
                    case "length":
                        return new NumericValue(operand.value.length);
                    case "upper":
                        return new StringValue(operand.value.toUpperCase());
                    case "lower":
                        return new StringValue(operand.value.toLowerCase());
                    case "title":
                        return new StringValue(titleCase(operand.value));
                    case "capitalize":
                        return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));
                    case "trim":
                        return new StringValue(operand.value.trim());
                    default:
                        throw new Error(`Unknown StringValue filter: ${filter.value}`);
                }
            } else if (operand instanceof NumericValue) {
                switch(filter.value){
                    case "abs":
                        return new NumericValue(Math.abs(operand.value));
                    default:
                        throw new Error(`Unknown NumericValue filter: ${filter.value}`);
                }
            } else if (operand instanceof ObjectValue) {
                switch(filter.value){
                    case "items":
                        return new ArrayValue(Array.from(operand.value.entries()).map(([key, value])=>new ArrayValue([
                                new StringValue(key),
                                value
                            ])));
                    case "length":
                        return new NumericValue(operand.value.size);
                    default:
                        throw new Error(`Unknown ObjectValue filter: ${filter.value}`);
                }
            }
            throw new Error(`Cannot apply filter "${filter.value}" to type: ${operand.type}`);
        } else if (node.filter.type === "CallExpression") {
            const filter = node.filter;
            if (filter.callee.type !== "Identifier") {
                throw new Error(`Unknown filter: ${filter.callee.type}`);
            }
            const filterName = filter.callee.value;
            if (operand instanceof ArrayValue) {
                switch(filterName){
                    case "selectattr":
                        {
                            if (operand.value.some((x)=>!(x instanceof ObjectValue))) {
                                throw new Error("`selectattr` can only be applied to array of objects");
                            }
                            if (filter.args.some((x)=>x.type !== "StringLiteral")) {
                                throw new Error("arguments of `selectattr` must be strings");
                            }
                            const [attr, testName, value] = filter.args.map((x)=>this.evaluate(x, environment));
                            let testFunction;
                            if (testName) {
                                const test = environment.tests.get(testName.value);
                                if (!test) {
                                    throw new Error(`Unknown test: ${testName.value}`);
                                }
                                testFunction = test;
                            } else {
                                testFunction = (...x)=>x[0].__bool__().value;
                            }
                            const filtered = operand.value.filter((item)=>{
                                const a = item.value.get(attr.value);
                                if (a) {
                                    return testFunction(a, value);
                                }
                                return false;
                            });
                            return new ArrayValue(filtered);
                        }
                }
                throw new Error(`Unknown ArrayValue filter: ${filterName}`);
            } else {
                throw new Error(`Cannot apply filter "${filterName}" to type: ${operand.type}`);
            }
        }
        throw new Error(`Unknown filter: ${node.filter.type}`);
    }
    /**
   * Evaluates expressions following the test operation type.
   */ evaluateTestExpression(node, environment) {
        const operand = this.evaluate(node.operand, environment);
        const test = environment.tests.get(node.test.value);
        if (!test) {
            throw new Error(`Unknown test: ${node.test.value}`);
        }
        const result = test(operand);
        return new BooleanValue(node.negate ? !result : result);
    }
    /**
   * Evaluates expressions following the unary operation type.
   */ evaluateUnaryExpression(node, environment) {
        const argument = this.evaluate(node.argument, environment);
        switch(node.operator.value){
            case "not":
                return new BooleanValue(!argument.value);
            default:
                throw new SyntaxError(`Unknown operator: ${node.operator.value}`);
        }
    }
    evalProgram(program, environment) {
        return this.evaluateBlock(program.body, environment);
    }
    evaluateBlock(statements, environment) {
        let result = "";
        for (const statement of statements){
            const lastEvaluated = this.evaluate(statement, environment);
            if (lastEvaluated.type !== "NullValue" && lastEvaluated.type !== "UndefinedValue") {
                result += lastEvaluated.value;
            }
        }
        return new StringValue(result);
    }
    evaluateIdentifier(node, environment) {
        return environment.lookupVariable(node.value);
    }
    evaluateCallExpression(expr, environment) {
        const args = [];
        const kwargs = /* @__PURE__ */ new Map();
        for (const argument of expr.args){
            if (argument.type === "KeywordArgumentExpression") {
                const kwarg = argument;
                kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));
            } else {
                args.push(this.evaluate(argument, environment));
            }
        }
        if (kwargs.size > 0) {
            args.push(new ObjectValue(kwargs));
        }
        const fn = this.evaluate(expr.callee, environment);
        if (fn.type !== "FunctionValue") {
            throw new Error(`Cannot call something that is not a function: got ${fn.type}`);
        }
        return fn.value(args, environment);
    }
    evaluateSliceExpression(object, expr, environment) {
        if (!(object instanceof ArrayValue || object instanceof StringValue)) {
            throw new Error("Slice object must be an array or string");
        }
        const start = this.evaluate(expr.start, environment);
        const stop = this.evaluate(expr.stop, environment);
        const step = this.evaluate(expr.step, environment);
        if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {
            throw new Error("Slice start must be numeric or undefined");
        }
        if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {
            throw new Error("Slice stop must be numeric or undefined");
        }
        if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {
            throw new Error("Slice step must be numeric or undefined");
        }
        if (object instanceof ArrayValue) {
            return new ArrayValue(slice(object.value, start.value, stop.value, step.value));
        } else {
            return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(""));
        }
    }
    evaluateMemberExpression(expr, environment) {
        const object = this.evaluate(expr.object, environment);
        let property;
        if (expr.computed) {
            if (expr.property.type === "SliceExpression") {
                return this.evaluateSliceExpression(object, expr.property, environment);
            } else {
                property = this.evaluate(expr.property, environment);
            }
        } else {
            property = new StringValue(expr.property.value);
        }
        let value;
        if (object instanceof ObjectValue) {
            if (!(property instanceof StringValue)) {
                throw new Error(`Cannot access property with non-string: got ${property.type}`);
            }
            value = object.value.get(property.value) ?? object.builtins.get(property.value);
        } else if (object instanceof ArrayValue || object instanceof StringValue) {
            if (property instanceof NumericValue) {
                value = object.value.at(property.value);
                if (object instanceof StringValue) {
                    value = new StringValue(object.value.at(property.value));
                }
            } else if (property instanceof StringValue) {
                value = object.builtins.get(property.value);
            } else {
                throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);
            }
        } else {
            if (!(property instanceof StringValue)) {
                throw new Error(`Cannot access property with non-string: got ${property.type}`);
            }
            value = object.builtins.get(property.value);
        }
        return value instanceof RuntimeValue ? value : new UndefinedValue();
    }
    evaluateSet(node, environment) {
        const rhs = this.evaluate(node.value, environment);
        if (node.assignee.type === "Identifier") {
            const variableName = node.assignee.value;
            environment.setVariable(variableName, rhs);
        } else if (node.assignee.type === "MemberExpression") {
            const member = node.assignee;
            const object = this.evaluate(member.object, environment);
            if (!(object instanceof ObjectValue)) {
                throw new Error("Cannot assign to member of non-object");
            }
            if (member.property.type !== "Identifier") {
                throw new Error("Cannot assign to member with non-identifier property");
            }
            object.value.set(member.property.value, rhs);
        } else {
            throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);
        }
        return new NullValue();
    }
    evaluateIf(node, environment) {
        const test = this.evaluate(node.test, environment);
        return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);
    }
    evaluateFor(node, environment) {
        const scope = new Environment(environment);
        const iterable = this.evaluate(node.iterable, scope);
        if (!(iterable instanceof ArrayValue)) {
            throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);
        }
        let result = "";
        for(let i = 0; i < iterable.value.length; ++i){
            const loop = /* @__PURE__ */ new Map([
                [
                    "index",
                    new NumericValue(i + 1)
                ],
                [
                    "index0",
                    new NumericValue(i)
                ],
                [
                    "revindex",
                    new NumericValue(iterable.value.length - i)
                ],
                [
                    "revindex0",
                    new NumericValue(iterable.value.length - i - 1)
                ],
                [
                    "first",
                    new BooleanValue(i === 0)
                ],
                [
                    "last",
                    new BooleanValue(i === iterable.value.length - 1)
                ],
                [
                    "length",
                    new NumericValue(iterable.value.length)
                ],
                [
                    "previtem",
                    i > 0 ? iterable.value[i - 1] : new UndefinedValue()
                ],
                [
                    "nextitem",
                    i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()
                ]
            ]);
            scope.setVariable("loop", new ObjectValue(loop));
            const current = iterable.value[i];
            if (node.loopvar.type === "Identifier") {
                scope.setVariable(node.loopvar.value, current);
            } else if (node.loopvar.type === "TupleLiteral") {
                const loopvar = node.loopvar;
                if (current.type !== "ArrayValue") {
                    throw new Error(`Cannot unpack non-iterable type: ${current.type}`);
                }
                const c = current;
                if (loopvar.value.length !== c.value.length) {
                    throw new Error(`Too ${loopvar.value.length > c.value.length ? "few" : "many"} items to unpack`);
                }
                for(let j = 0; j < loopvar.value.length; ++j){
                    if (loopvar.value[j].type !== "Identifier") {
                        throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);
                    }
                    scope.setVariable(loopvar.value[j].value, c.value[j]);
                }
            }
            const evaluated = this.evaluateBlock(node.body, scope);
            result += evaluated.value;
        }
        return new StringValue(result);
    }
    evaluate(statement, environment) {
        if (statement === void 0) return new UndefinedValue();
        switch(statement.type){
            case "Program":
                return this.evalProgram(statement, environment);
            case "Set":
                return this.evaluateSet(statement, environment);
            case "If":
                return this.evaluateIf(statement, environment);
            case "For":
                return this.evaluateFor(statement, environment);
            case "NumericLiteral":
                return new NumericValue(Number(statement.value));
            case "StringLiteral":
                return new StringValue(statement.value);
            case "BooleanLiteral":
                return new BooleanValue(statement.value);
            case "ArrayLiteral":
                return new ArrayValue(statement.value.map((x)=>this.evaluate(x, environment)));
            case "TupleLiteral":
                return new TupleValue(statement.value.map((x)=>this.evaluate(x, environment)));
            case "ObjectLiteral":
                {
                    const mapping = /* @__PURE__ */ new Map();
                    for (const [key, value] of statement.value){
                        const evaluatedKey = this.evaluate(key, environment);
                        if (!(evaluatedKey instanceof StringValue)) {
                            throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);
                        }
                        mapping.set(evaluatedKey.value, this.evaluate(value, environment));
                    }
                    return new ObjectValue(mapping);
                }
            case "Identifier":
                return this.evaluateIdentifier(statement, environment);
            case "CallExpression":
                return this.evaluateCallExpression(statement, environment);
            case "MemberExpression":
                return this.evaluateMemberExpression(statement, environment);
            case "UnaryExpression":
                return this.evaluateUnaryExpression(statement, environment);
            case "BinaryExpression":
                return this.evaluateBinaryExpression(statement, environment);
            case "FilterExpression":
                return this.evaluateFilterExpression(statement, environment);
            case "TestExpression":
                return this.evaluateTestExpression(statement, environment);
            default:
                throw new SyntaxError(`Unknown node type: ${statement.type}`);
        }
    }
};
function convertToRuntimeValues(input) {
    switch(typeof input){
        case "number":
            return new NumericValue(input);
        case "string":
            return new StringValue(input);
        case "boolean":
            return new BooleanValue(input);
        case "object":
            if (input === null) {
                return new NullValue();
            } else if (Array.isArray(input)) {
                return new ArrayValue(input.map(convertToRuntimeValues));
            } else {
                return new ObjectValue(new Map(Object.entries(input).map(([key, value])=>[
                        key,
                        convertToRuntimeValues(value)
                    ])));
            }
        case "function":
            return new FunctionValue((args, _scope)=>{
                const result = input(...args.map((x)=>x.value)) ?? null;
                return convertToRuntimeValues(result);
            });
        default:
            throw new Error(`Cannot convert to runtime value: ${input}`);
    }
}
// src/index.ts
var Template = class {
    parsed;
    /**
   * @param {string} template The template string
   */ constructor(template){
        const tokens = tokenize(template, {
            lstrip_blocks: true,
            trim_blocks: true
        });
        this.parsed = parse(tokens);
    }
    render(items) {
        const env = new Environment();
        env.set("false", false);
        env.set("true", true);
        env.set("raise_exception", (args)=>{
            throw new Error(args);
        });
        env.set("range", range);
        for (const [key, value] of Object.entries(items)){
            env.set(key, value);
        }
        const interpreter = new Interpreter(env);
        const result = interpreter.run(this.parsed);
        return result.value;
    }
};
;
}}),
}]);

//# sourceMappingURL=node_modules_e058db4f._.js.map